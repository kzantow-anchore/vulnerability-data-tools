package main

import (
	"encoding/json"
	"io"
	"os"
	"path"
	"slices"
	"strings"

	"github.com/bmatcuk/doublestar/v4"

	"github.com/anchore/go-sync"
	nvd2 "github.com/anchore/grype-db/pkg/provider/unmarshal/nvd"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cve"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/nvd"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/termset"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

func printCvesWithoutCpes(filter string, writer io.Writer) {
	nvdCvesWithCpes := getKnownCveToCpes(nvdDbFile, filter)

	collector := sync.NewCollector[string](sync.NewExecutor(-1))

	// get all CVE IDs known from the cve list that don't have any CPEs
	fileGlob := path.Join(cveListDir, "*/**/*.json")
	cveFilePaths := util.Get(doublestar.FilepathGlob(fileGlob))
	for _, cveFile := range cveFilePaths {
		cveFile := cveFile
		collector.Provide(func() string {
			var cveRec cve.Record
			util.Log(json.Unmarshal(util.Get(os.ReadFile(cveFile)), &cveRec))

			if cveRec.Metadata.State == "REJECTED" {
				// skip rejected CVEs, as they may be wrong or just have no data
				return ""
			}

			cveID := cve.NormalizeCve(cveRec.Metadata.ID)
			if cveID == "" {
				util.Log("no cveId in:", cveFile)
				return ""
			}

			for _, affected := range cveRec.Containers.Cna.Affected {
				if len(affected.Cpes) > 0 {
					return ""
				}
			}

			if nvdCvesWithCpes.Has(cveID) {
				return ""
			}

			return cveID
		})
	}

	// remove CVEs that have CPEs in the NVD data
	cveIDs := termset.New(collector.Collect()...).List()

	slices.Sort(cveIDs)

	for _, cveID := range cveIDs {
		if cveID == "" {
			continue
		}
		_, _ = writer.Write([]byte(strings.ToUpper(cveID)))
		_, _ = writer.Write([]byte("\n"))
	}
}

func getKnownCveToCpes(nvdDbFile string, filter string) util.Set[string] {
	cvesWithCpes := util.NewSet[string]()

	for _, vuln := range nvd.ReadVulnerabilities(nvdDbFile, filter) {
		if hasCpe(vuln.Cve) {
			cvesWithCpes.Add(cve.NormalizeCve(vuln.Cve.ID))
		}
	}

	return cvesWithCpes
}

func hasCpe(c nvd2.CveItem) bool {
	for _, conf := range c.Configurations {
		for _, node := range conf.Nodes {
			for _, cpeMatch := range node.CpeMatch {
				if cpeMatch.Criteria != "" {
					return true
				}
			}
		}
	}
	return false
}

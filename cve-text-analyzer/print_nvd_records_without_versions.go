package main

import (
	"fmt"
	"io"
	"path"
	"strings"

	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cve"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/nvd"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

func printRecordsWithVersionsNotMatchingRegex(filter string, writer io.Writer) {
	testMatch := func(cveId string, version *string) {
		if version == nil || *version == "" {
			return
		}
		// certain characters are escaped in the strings
		str := strings.ReplaceAll(*version, "\\", "")
		if !versionRegex.MatchString(str) {
			// ignore letter-only versions, we're just going to skip them
			if knownIgnoredVersionRegex.MatchString(str) {
				return
			}
			_, _ = fmt.Fprintf(writer, "UNMATCHED: %s: %s\n", cveId, str)
		}
	}

	nvd.ForEachVulnerability(nvdDbFile, filter, func(vuln nvd.Vulnerability) {
		cpeMatches := allCpeMatches(vuln)
		cveId := cve.NormalizeCve(vuln.Cve.ID)
		for _, m := range cpeMatches {
			testMatch(cveId, m.VersionStartIncluding)
			testMatch(cveId, m.VersionStartExcluding)
			testMatch(cveId, m.VersionEndExcluding)
			testMatch(cveId, m.VersionEndExcluding)
			//testMatch(cveId, &m.Criteria)
		}
	})

}

func printRecordsWithoutVersions(filter string, writer io.Writer) {
	nvdRecords := map[string]nvd.Vulnerability{}

	nvd.ForEachVulnerability(nvdDbFile, filter, func(vuln nvd.Vulnerability) {
		nvdRecords[cve.NormalizeCve(vuln.Cve.ID)] = vuln
	})

	fileGlob := path.Join(cveListDir, fmt.Sprintf("*/**/%s*.json", filter))
	cves := cve.ReadFiles(fileGlob)
	util.Log("CVEs without Versions:")
	_, _ = fmt.Fprintf(writer, "cve,state,published,updated\n")
	for _, c := range cves {
		// skip rejected records
		if c.Metadata.State == cve.StateRejected {
			continue
		}
		cveId := cve.NormalizeCve(c.Metadata.ID)
		vuln := nvdRecords[cveId]
		cpeMatches := allCpeMatches(vuln)
		if len(cpeMatches) == 0 {
			_, _ = fmt.Fprintf(writer, "%s,%s,%s,%s\n", c.Metadata.ID, c.Metadata.State, c.Metadata.Published, c.Metadata.Updated)
		} else {
			for _, m := range cpeMatches {
				if m.VersionStartExcluding != nil {
					util.Log("!!!!!!!!! VERSION START EXCLUDING:", vuln.Cve.ID, ": ", *m.VersionStartExcluding)
				}
			}
		}
	}
}

func getKnownCpeMatches(nvdDbFile string, filter string) map[string][]nvd.CpeMatch {
	out := map[string][]nvd.CpeMatch{}
	nvd.ForEachVulnerability(nvdDbFile, filter, func(vuln nvd.Vulnerability) {
		cveId := cve.NormalizeCve(vuln.Cve.ID)
		ranges := out[cveId]
		ranges = append(ranges, allCpeMatches(vuln)...)
		if len(ranges) > 0 {
			out[cveId] = ranges
		}
	})

	return out
}

func allCpeMatches(vuln nvd.Vulnerability) []nvd.CpeMatch {
	var out []nvd.CpeMatch
	for _, conf := range vuln.Cve.Configurations {
		negate := false
		if conf.Negate != nil && *conf.Negate {
			negate = true
		}
		for _, node := range conf.Nodes {
			negateNode := negate
			if node.Negate != nil && *node.Negate {
				negateNode = !negateNode
			}
			for _, cpeMatch := range node.CpeMatch {
				if !cpeMatch.Vulnerable {
					continue
				}
				out = append(out, cpeMatch)
			}
		}
	}
	return out
}

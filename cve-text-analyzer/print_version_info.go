package main

import (
	"fmt"
	"io"
	"path"
	"regexp"
	"strings"

	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/cve"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/reader/nvd"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/termset"
	"github.com/anchore/vulnerability-data-tools/cve-text-analyzer/internal/util"
)

type versionContext struct {
	pre     termset.Set
	post    termset.Set
	version string
}

func (c *versionContext) Pre(terms ...string) bool {
	for _, t := range terms {
		if !c.pre.Has(t) {
			return false
		}
	}
	return true
}

func (c *versionContext) Post(terms ...string) bool {
	for _, t := range terms {
		if !c.post.Has(t) {
			return false
		}
	}
	return true
}

type versionRange struct {
	gt      bool
	lt      bool
	equal   bool
	version string
}

func (r *versionRange) String() string {
	switch {
	case r.gt && r.equal:
		return ">=" + r.version
	case r.gt:
		return ">" + r.version
	case r.lt && r.equal:
		return "<=" + r.version
	case r.lt:
		return "<" + r.version
	}
	if r.version != "" {
		return r.version
	}
	return "UNKNOWN"
}

func printVersionsSummary(filter string, writer io.Writer) {
	nvdRecords := map[string]nvd.Vulnerability{}
	nvd.ForEachVulnerability(nvdDbFile, filter, func(vuln nvd.Vulnerability) {
		nvdRecords[vuln.Cve.ID] = vuln
	})

	write := func(parts ...string) {
		for _, p := range parts {
			_, _ = writer.Write([]byte(p))
		}
	}
	writeLn := func(parts ...string) { write(append(parts, "\n")...) }

	fileGlob := path.Join(cveListDir, fmt.Sprintf("*/**/*%s*.json", filter))
	cves := cve.ReadFiles(fileGlob)
	for _, cve := range cves {
		writeLn(cve.Metadata.ID, ":")
		writeLn("  NVD Versions:")
		r, ok := nvdRecords[cve.Metadata.ID]
		if !ok {
			writeLn("    !NOT FOUND!")
		} else {
			for _, conf := range r.Cve.Configurations {
				for _, n := range conf.Nodes {
					for _, m := range n.CpeMatch {
						write("    - ")
						if m.Vulnerable {
							write("vuln ")
						} else {
							write("fix ")
						}
						if m.VersionStartIncluding != nil {
							write(*m.VersionStartIncluding, "<= ")
						}
						if m.VersionStartExcluding != nil {
							write(*m.VersionStartExcluding, "< ")
						}
						if m.VersionEndIncluding != nil {
							write(" <=", *m.VersionEndExcluding)
						}
						if m.VersionEndExcluding != nil {
							write(" <", *m.VersionEndExcluding)
						}
						writeLn("  (criteria: ", m.Criteria, ")")
					}
				}
			}
		}
		writeLn("  Versions:")
		for _, a := range cve.Containers.Cna.Affected {
			for _, v := range a.Versions {
				write("   - ")
				if v.LessThan != "" {
					write("<", v.LessThan)
				}
				if v.LessThanOrEqual != "" {
					write("<=", v.LessThanOrEqual)
				}
				writeLn(" ; ", v.Version)
			}
		}
		var text []string
		for _, t := range cve.Containers.Cna.Descriptions {
			text = append(text, t.Value)
		}
		allText := strings.Join(text, " ")

		extractedVersions := extractVersions(allText)
		writeLn("  Extracted Versions:")
		for _, v := range extractedVersions {
			writeLn("    - ", v.String())
		}

		writeLn("  Text:")
		writeLn(util.PrefixLines(allText, "    "))
	}
}

func extractVersions(text string) []versionRange {
	var out []versionRange
	// analyze the text
	for _, vc := range extractVersionContexts(text) {
		out = append(out, versionRange{
			gt:      isTopRange(vc),
			lt:      isBottomRange(vc),
			equal:   isInclusive(vc),
			version: vc.version,
		})
	}
	// combine bottom/top ranges if possible

	return out
}

func isTopRange(vc versionContext) bool {
	if vc.Pre("up", "to") ||
		vc.Pre("before") {
		return true
	}
	return false
}

func isBottomRange(vc versionContext) bool {
	if vc.Pre("up", "to") ||
		vc.Pre("after") {
		return true
	}
	return false

}

func isInclusive(vc versionContext) bool {
	if vc.Pre("including") {
		return true
	}
	return false

}

func extractVersionContexts(text string) []versionContext {
	var out []versionContext
	parts := util.TermSeparator.Split(text, -1)
	for i, part := range parts {
		if versionRegex.MatchString(part) {
			version := part
			// see if part of a larger version
			j := i
			for ; j+1 < len(parts) && versionSuffixRegex.MatchString(parts[j+1]); j++ {
				version += " " + parts[j+1]
			}
			out = append(out, versionContext{
				version: version,
				pre:     rangeFrom(parts, i, -4),
				post:    rangeFrom(parts, j, 4),
			})
		}
	}
	return out
}

func rangeFrom(parts []string, index int, termCount int) termset.Set {
	out := termset.New()
	if termCount < 0 {
		index = index + termCount - 1
		termCount = -termCount
	} else {
		index++
	}
	end := index + termCount
	for ; index < end; index++ {
		if index < 0 || index >= len(parts) {
			continue
		}
		term := parts[index]
		term = strings.ToLower(term)
		out.Add(term)
	}
	return out
}

var (
	versionRegex = regexp.MustCompile(
		"^([a-z][-_.a-z]*)*[0-9][-.+:_()^/0-9a-zA-Z]*$",
	)
	versionStartRegex = regexp.MustCompile(
		"^[v]?[0-9][-.+:_0-9a-zA-Z]+$",
	)
	versionSuffixRegex = regexp.MustCompile(
		"^[r][0-9][0-9a-zA-Z]+$",
	)
	knownIgnoredVersionRegex = regexp.MustCompile(
		`^[-a-zA-Z]+$`,
	)
)
